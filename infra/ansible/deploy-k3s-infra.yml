---
- name: Deploy k3s Infrastructure
  hosts: localhost
  gather_facts: yes
  vars:
    playbook_title: "Deploy k3s Infrastructure"
    playbook_description: "Deploy and manage k3s infrastructure"
    app_name: ""
    app_path: ""
    deploy_action: "up"  # up, down, restart, pull

  tasks:
    - name: Set default deployment status
      debug:
        msg: "Starting deployment...{{ postgres.host }}:{{ postgres.port }}"
    # - name: Validate required variables
    #   assert:
    #     that:
    #       - app_name is defined and app_name != ""
    #       - app_path is defined and app_path != ""
    #     fail_msg: "app_name and app_path variables are required"

    # - name: Deploy Docker Compose Application
    #   block:
    #     - name: Ensure Docker is running
    #       systemd:
    #         name: docker
    #         state: started
    #         enabled: yes

    #     - name: Ensure Docker Compose plugin is available
    #       command: docker compose version
    #       register: compose_check
    #       failed_when: false
    #       changed_when: false

    #     - name: Create application directory
    #       file:
    #         path: "{{ repo_path }}/{{ app_path }}"
    #         state: directory
    #         mode: '0755'

    #     - name: Check if docker-compose file exists
    #       stat:
    #         path: "{{ repo_path }}/{{ app_path }}/{{ compose_file }}"
    #       register: compose_file_check

    #     - name: Fail if docker-compose file doesn't exist
    #       fail:
    #         msg: "Docker compose file {{ repo_path }}/{{ app_path }}/{{ compose_file }} not found"
    #       when: not compose_file_check.stat.exists

    #     - name: Pull latest images
    #       command: docker compose pull
    #       args:
    #         chdir: "{{ repo_path }}/{{ app_path }}"
    #       when: deploy_action in ['up', 'pull', 'restart']

    #     - name: Stop services (if restart or down)
    #       command: docker compose down
    #       args:
    #         chdir: "{{ repo_path }}/{{ app_path }}"
    #       when: deploy_action in ['down', 'restart']

    #     - name: Start services (if up or restart)
    #       command: docker compose up -d
    #       args:
    #         chdir: "{{ repo_path }}/{{ app_path }}"
    #       environment:
    #         POSTGRES_USER: "{{ postgres_user | default('postgres') }}"
    #         POSTGRES_PASSWORD: "{{ postgres_password | default('defaultpassword') }}"
    #         POSTGRES_DB: "{{ postgres_db | default('postgres') }}"
    #       when: deploy_action in ['up', 'restart']

    #     - name: Wait for services to start
    #       pause:
    #         seconds: 10
    #       when: deploy_action in ['up', 'restart']

    #     - name: Get container status
    #       command: docker compose ps
    #       args:
    #         chdir: "{{ repo_path }}/{{ app_path }}"
    #       register: container_status
    #       when: deploy_action in ['up', 'restart']

    #     - name: Display container status
    #       debug:
    #         msg: "{{ container_status.stdout_lines }}"
    #       when: container_status is defined

    #     - name: Set status to success
    #       set_fact:
    #         status: "success"
    #         status_color: 255
    #         deployment_message: "{{ app_name }} deployed successfully on {{ inventory_hostname }}"

    #   rescue:
    #     - name: Set status to fail
    #       set_fact:
    #         status: "fail"
    #         status_color: 16711680
    #         deployment_message: "{{ app_name }} deployment failed on {{ inventory_hostname }}: {{ ansible_failed_result.msg }}"

    #     - name: Show error details
    #       debug:
    #         msg: "Deployment failed: {{ ansible_failed_result }}"


    - name: Summary
      debug:
        msg: |
          Deployment Summary:
          - Application: {{ app_name }}
          - Host: {{ inventory_hostname }}
          - Action: {{ deploy_action }}
          - Status: {{ status }}
          - Message: {{ deployment_message }}